# 15장 엔터티와 인코딩

**개요** 

HTTP는 다음을 보장한다

- 객체의 올바른 식별 `Content-Type` `Content-Languange`
- 객체의 올바른 압축 해제 `Content-Length` `Content-Encoding`
- 항상 최신인 객체 `엔터티 검사기` `캐시 만료 제어`
- 사용자의 요구 만족 `내용협상을 위한 Accept 관련 헤더`
- 빠르고 효율적인 데이터 전송 `범위 요청` `델타 인코딩` `데이터 압축`
- 조작되지 않음 `전송 인코딩 헤더` `Content-MD6 체크섬`

이 모든 것들을 가능하게 하기 위해, http는 콘텐츠를 나르기 위한 잘 라벨링된 엔터티를 사용한다.

---

### 15.1 메세지는 컨테이너, 엔터티는 화물

1. **메세지 엔터티는 엔터티 헤더와 엔터티 본문으로 이루어진다.**  
  
2. **10가지 주요 엔터티 헤더 필드** 
    - *Content-Type*
        - 엔터티에 의해 전달된 객체의 종류
        - 엔터티 본문의 MIME 타입을 담고 있다.
        - `text/html` `image/gif` `audio/x-wave`
    - *Content-Length*
        - 전달되는 메시지의 길이나 크기
        - 커넥션이 닫힐 때 메세지가 잘렸는지/ 정상적으로 닫힌건지 검사할 때 사용되어 필수 헤더이다. (지속 커넥션을 이용할 때도 필수)
        - *Content-Length* 헤더를 통해 메세지 시작과 끝을 파악한다. 본문이 인코딩 되어 있다면, 인코딩 된 길이로 정의한다.
    - *Content-Language*
        - 전달되는 객체와 가장 잘 대응되는 자연어
    - *Content-Encoding*
        - 객체 데이터에 대해 행해진 변형(압축 등)
    - *Content-Range*
        - 만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의한다.
    - *Content-MD5*
        - 엔터티 본문의 콘텐츠에 대한 체크섬
        - TCP/IP와 같이 신뢰할만한 프로토콜에서도 메세지 일부가 변형될 수 있다. 수신자가 엔터티의 변경을 잡아내기 위해 체크섬으로 검사를 하게 된다.
    - *Last-Modified* (엔터티 캐싱 헤더)
        - 서버에서 이 콘텐츠가 생성 혹은 수정된 날
    - *Expires*  (엔터티 캐싱 헤더)
        - 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각
    - *Allow*
        - 이 리소스에 대해 어떤 메서드가 허용되는지. 예) GET과 HEAD
    - *ETag*  (엔터티 캐싱 헤더)
        - 이 인스턴스에 대한 고유한 검사기.
        - 엄밀히 말해 ETag 헤더는 엔터티 헤더로 정의되어 있지는 않지만 엔터티와 관련된 많은 동작을 위해 중요한 헤더이다.
    - *Cache-Control*
        - 어떻게 이 문서가 캐시될 수 있는지에 대한 지시자. ETag 헤더와 마찬가지로 Cache-Control 헤더도 엔터티 헤더로 정의되어 있지는 않다.
3. **엔터티 본문**
    - 엔터티 본문이 raw단 데이터이기 때문에 엔터티 헤더가 본문에 대한 의미를 내포한다.
    - 헤더와 본문은 빈 줄(CRLF)로 구분된다.

---

### 15.2 Content-Length: 엔터티의 길이

1. ***Content-Length* 헤더**
    - 메세지의 엔터티 본문의 크기를 바이트 단위로 나타낸다. 압축된 텍스트 파일이라면 압축된 후의 크기로 나타낸다.
    - 메세지를 청크 인코딩으로 전송하지 않는 이상, 필수로 존재해야 한다.
        - 서버 충돌로 인해 메세지가 잘렸는지 감지하고자 할 때
        - 지속 커넥션을 공유하는 메세지를 올바르게 분할하고자 할 때
            
            (지속 커넥션: TCP 커넥션의 재활용 → 처리가 완료된 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용한다. )
            
2. **잘림 검출**
    - Content-Length가 없다면 클라이언트는 커넥션이 정상적으로 닫힌 것인지 메시지 전송 중에 서버에 충돌이 발생한 것인지 구별하지 못한다.
    - 캐싱 프락시 서버에 특히 취약 → 캐시가 잘린 메세지를 수신했을 때, 결함있는 캐시를 계속해서 제공할 것이기 때문이다. 없으면 캐시 안함
3. **잘못된 *Content-Length***
    - 없는 것보다도 더 큰 피해를 유발한다. HTTP/1.1 부터는 인지했을 때 사용자에게 알려주게 되어 있다.
4. ***Content-Length*와 지속 커넥션**
    - 응답이 지속 커넥션을 통해서 온 것이라면, HTTP 응답이 즉시 그 뒤를 이을 것이다. 지속 커넥션이기 때문에 클라이언트가 커넥션이 닫힌 위치를 근거로 메세지의 끝을 인식하는 것이 불가능하다. 띠라서, *Content-Length*없이는 어디까지가 본문이고 다음 메세지인지 구분 못한다.
    - 청크 인코딩에서는 필수가 아니다. → 15.6 상현님께서..^^
5. **콘텐츠 인코딩**
    - HTTP는 보안을 강화하거나 압축하기 위해 본문을 인코딩하는데, 콘텐츠가 인코딩되어 있다면 Content-Length는 인코딩된 본문의 길이를 바이트 단위로 정의한다.
6. **엔터티 본문 길이 판별을 위한 규칙**
    1. 본문을 갖는 것이 허용되지 않는 http 메세지에서는 Content-Length헤더가 무시된다.
    2. 메세지가 Transfer-Encoding(청크 인코딩 헤더)를 포함할 경우 '0바이트 청크'라는 특별한 패턴으로 끝나야 한다. 이 헤더가 있을 경우 Content-Length헤더를 무시해야 한다.
    3. Content-Length 헤더를 갖고 Transfer-Encoding 헤더가 없다면 Content-Length헤더는 본문의 길이를 담게 된다.
    4. 'multipart/byteranges' 미디터 타입을 사용하고 엔터티 길이가 정의되지 않았다면, 메세지의 각 부분은 각자가 스스로의 크기를 정의할 것이다.
    5. 위의 규칙에 해당 사항이 없을 경우, 서버만이 메세지가 끝났음을 알리기 위해서 커넥션을 닫을 수 있다.

---

### 15.3 엔터티 요약

- 엔터티 본문 데이터 변경을 감지하기 위해, 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬을 생성할 수 있으며 수신자는 엔터티 변경을 잡아내기 위해 체크섬으로 기본적인 검사를 할 수 있다.
- Content-MD5 헤더는 엔터티 본문에 적용한 MD5 알고리즘에 대한 결과를 보여준다. 이를 통해 무결성을 검증한다.
    - 메세지의 무결성을 검증하려는 클라이언트는 먼저 인코딩을 디코딩 한 뒤,
    - 디코딩 된 엔터티 본문에 대해 MD5를 계산해야 한다.

---

### 15.4 미디어 타입과 차셋

- *Content-Type* 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다.

1. 텍스트 매체를 위한 문자 인코딩
    - 내용 유형을 더 자세히 지정하기 위한 선택적 매개변수 지원 → charset
    - `Content-Type: text/html; charset=utf-8`
2. 멀티파트 미디어 타입
    - 여러개의 메세지를 포함하여 하나의 복합 메세지로 보내진다.
    - 구성 요소가 이어져 있고, 문자열 하나로 경계가 식별
    - 두가지 경우에만 사용
        - 폼을 채워서 제출할 때
        - 문서의 일부분을 실어나르는 범위 응답을 할 때
3. 멀티파트 폼 제출
    - 텍스트 입력 필드 “Sally”입력 && “essayfile.txt”를 선택
    - 이미지 파일로 “imagefile.gif” 선택
    
    ⇒ 사용자 에이전트는 다음과 같은 데이터를 돌려보냄
    
4. 멀티파트 범위 응답
    - 범위 요청에 대한  HTTP응답 또한 멀티 파트가 될수 있다.
    - 이런 응답은 Content-Type: multipart/byteranges 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 온다. → 뒷 부분에서 더 자세히!